options {
  LOOKAHEAD = 1;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  STATIC = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = false;
  UNICODE_INPUT = false;
  IGNORE_CASE = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
  OUTPUT_DIRECTORY = "jccgen";
}

/**
* Parses .bench files of ITC99 benchmark circuits
*/

PARSER_BEGIN(CircuitParser)
package com.juliasoft.beedeedee.examples.circuits.jccgen;

import java.util.ArrayList;
import java.util.HashMap;
import com.juliasoft.beedeedee.examples.circuits.Operation;

public class CircuitParser {
    private ArrayList<String> inputs = new ArrayList<String>();
    private ArrayList<String> outputs = new ArrayList<String>();
    private HashMap<String,Operation> opMap = new HashMap<String,Operation>();

    public ArrayList<String> getInputs() {
        return inputs;
    }
    
    public ArrayList<String> getOutputs() {
        return outputs;
    }

    public HashMap<String,Operation> getOpMap() {
        return opMap;
    }
}

PARSER_END(CircuitParser)

SKIP:
{
<" " | "\n" | "\r" | "\t">
| <"#"(~["\n"])* "\n"> // comment
}

TOKEN:
{
  < LP: "(" >
| < RP: ")" >
| < COMMA: "," >
| < EQ: "=" >
| < INPUT: "INPUT" >
| < OUTPUT: "OUTPUT" >
| < DFF: "DFF" >
| < AND: "AND" >
| < NAND: "NAND" >
| < OR: "OR" >
| < NOR: "NOR" >
| < NOT: "NOT" >
| < ID: (["_","A"-"Z","0"-"9"])+ >
}


/*
* A list of statements or whitespaces.
*/
void Start():
{}
{
    (  InputDeclaration() | OutputDeclaration() | Assignment() )*
}

void InputDeclaration():
{
  Token t;
}
{
  <INPUT> <LP> t = < ID > <RP>
  {
    inputs.add(t.image);
    
  }
}

void OutputDeclaration():
{
  Token t;
}
{
  <OUTPUT> <LP> t = < ID > <RP>
  {
    outputs.add(t.image);
  }
}

void Assignment():
{
  Token id, op;
  ArrayList<String> args;}
{
  id = < ID > < EQ >
  (
    op = < DFF >
  | op = < AND >
  | op = < NAND >
  | op = < OR >
  | op = < NOR >
  | op = < NOT >
  )

  <LP> args = IdList() <RP>
  {
    opMap.put(id.image, new Operation(op.image, args));  }
}

ArrayList<String> IdList():
{
  ArrayList<String> ids = new ArrayList<String>();
  Token t;}
{
  (
    t = < ID >    {
      ids.add(t.image);    }
    (
      < COMMA > t = < ID >        {
        ids.add(t.image);
      }
    )*  )

  {    return ids;
  }}

